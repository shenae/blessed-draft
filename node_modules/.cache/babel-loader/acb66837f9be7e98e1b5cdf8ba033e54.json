{"ast":null,"code":"'use strict';\n/**\n * Module dependencies\n */\n\nvar url = require('url');\n\nvar Streamparser = require('./parser');\n\nvar request = require('request');\n\nvar extend = require('deep-extend'); // Package version\n\n\nvar VERSION = require('../package.json').version;\n\nfunction Twitter(options) {\n  if (!(this instanceof Twitter)) {\n    return new Twitter(options);\n  }\n\n  this.VERSION = VERSION; // Merge the default options with the client submitted options\n\n  this.options = extend({\n    consumer_key: null,\n    consumer_secret: null,\n    access_token_key: null,\n    access_token_secret: null,\n    bearer_token: null,\n    rest_base: 'https://api.twitter.com/1.1',\n    stream_base: 'https://stream.twitter.com/1.1',\n    user_stream_base: 'https://userstream.twitter.com/1.1',\n    site_stream_base: 'https://sitestream.twitter.com/1.1',\n    media_base: 'https://upload.twitter.com/1.1',\n    request_options: {\n      headers: {\n        Accept: '*/*',\n        Connection: 'close',\n        'User-Agent': 'node-twitter/' + VERSION\n      }\n    }\n  }, options); // Default to user authentication\n\n  var authentication_options = {\n    oauth: {\n      consumer_key: this.options.consumer_key,\n      consumer_secret: this.options.consumer_secret,\n      token: this.options.access_token_key,\n      token_secret: this.options.access_token_secret\n    }\n  }; // Check to see if we are going to use User Authentication or Application Authetication\n\n  if (this.options.bearer_token) {\n    authentication_options = {\n      headers: {\n        Authorization: 'Bearer ' + this.options.bearer_token\n      }\n    };\n  } // Configure default request options\n\n\n  this.request = request.defaults(extend(this.options.request_options, authentication_options)); // Check if Promise present\n\n  this.allow_promise = typeof Promise === 'function';\n}\n\nTwitter.prototype.__buildEndpoint = function (path, base) {\n  var bases = {\n    'rest': this.options.rest_base,\n    'stream': this.options.stream_base,\n    'user_stream': this.options.user_stream_base,\n    'site_stream': this.options.site_stream_base,\n    'media': this.options.media_base\n  };\n  var endpoint = bases.hasOwnProperty(base) ? bases[base] : bases.rest; // if full url is specified we use that\n\n  var isFullUrl = url.parse(path).protocol !== null;\n\n  if (isFullUrl) {\n    endpoint = path;\n  } else {\n    // If the path begins with media or /media\n    if (path.match(/^(\\/)?media/)) {\n      endpoint = bases.media;\n    }\n\n    endpoint += path.charAt(0) === '/' ? path : '/' + path;\n  } // Remove trailing slash\n\n\n  endpoint = endpoint.replace(/\\/$/, '');\n\n  if (!isFullUrl) {\n    // Add json extension if not provided in call... only if a full url is not specified\n    endpoint += path.split('.').pop() !== 'json' ? '.json' : '';\n  }\n\n  return endpoint;\n};\n\nTwitter.prototype.__request = function (method, path, params, callback) {\n  var base = 'rest',\n      promise = false; // Set the callback if no params are passed\n\n  if (typeof params === 'function') {\n    callback = params;\n    params = {};\n  } // Return promise if no callback is passed and promises available\n  else if (callback === undefined && this.allow_promise) {\n      promise = true;\n    } // Set API base\n\n\n  if (typeof params.base !== 'undefined') {\n    base = params.base;\n    delete params.base;\n  } // Build the options to pass to our custom request object\n\n\n  var options = {\n    method: method.toLowerCase(),\n    // Request method - get || post\n    url: this.__buildEndpoint(path, base) // Generate url\n\n  }; // Pass url parameters if get\n\n  if (method === 'get') {\n    options.qs = params;\n  } // Pass form data if post\n\n\n  if (method === 'post') {\n    var formKey = 'form';\n\n    if (typeof params.media !== 'undefined') {\n      formKey = 'formData';\n    }\n\n    options[formKey] = params;\n  } // Promisified version\n\n\n  if (promise) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.request(options, function (error, response, data) {\n        // request error\n        if (error) {\n          return reject(error);\n        } // JSON parse error or empty strings\n\n\n        try {\n          // An empty string is a valid response\n          if (data === '') {\n            data = {};\n          } else {\n            data = JSON.parse(data);\n          }\n        } catch (parseError) {\n          return reject(new Error('JSON parseError with HTTP Status: ' + response.statusCode + ' ' + response.statusMessage));\n        } // response object errors\n        // This should return an error object not an array of errors\n\n\n        if (data.errors !== undefined) {\n          return reject(data.errors);\n        } // status code errors\n\n\n        if (response.statusCode < 200 || response.statusCode > 299) {\n          return reject(new Error('HTTP Error: ' + response.statusCode + ' ' + response.statusMessage));\n        } // no errors\n\n\n        resolve(data);\n      });\n    });\n  } // Callback version\n\n\n  this.request(options, function (error, response, data) {\n    // request error\n    if (error) {\n      return callback(error, data, response);\n    } // JSON parse error or empty strings\n\n\n    try {\n      // An empty string is a valid response\n      if (data === '') {\n        data = {};\n      } else {\n        data = JSON.parse(data);\n      }\n    } catch (parseError) {\n      return callback(new Error('JSON parseError with HTTP Status: ' + response.statusCode + ' ' + response.statusMessage), data, response);\n    } // response object errors\n    // This should return an error object not an array of errors\n\n\n    if (data.errors !== undefined) {\n      return callback(data.errors, data, response);\n    } // status code errors\n\n\n    if (response.statusCode < 200 || response.statusCode > 299) {\n      return callback(new Error('HTTP Error: ' + response.statusCode + ' ' + response.statusMessage), data, response);\n    } // no errors\n\n\n    callback(null, data, response);\n  });\n};\n/**\n * GET\n */\n\n\nTwitter.prototype.get = function (url, params, callback) {\n  return this.__request('get', url, params, callback);\n};\n/**\n * POST\n */\n\n\nTwitter.prototype.post = function (url, params, callback) {\n  return this.__request('post', url, params, callback);\n};\n/**\n * STREAM\n */\n\n\nTwitter.prototype.stream = function (method, params, callback) {\n  if (typeof params === 'function') {\n    callback = params;\n    params = {};\n  }\n\n  var base = 'stream';\n\n  if (method === 'user' || method === 'site') {\n    base = method + '_' + base;\n  }\n\n  var url = this.__buildEndpoint(method, base);\n\n  var request = this.request({\n    url: url,\n    qs: params\n  });\n  var stream = new Streamparser();\n\n  stream.destroy = function () {\n    // FIXME: should we emit end/close on explicit destroy?\n    if (typeof request.abort === 'function') {\n      request.abort(); // node v0.4.0\n    } else {\n      request.socket.destroy();\n    }\n  };\n\n  request.on('response', function (response) {\n    if (response.statusCode !== 200) {\n      stream.emit('error', new Error('Status Code: ' + response.statusCode));\n    } else {\n      stream.emit('response', response);\n    }\n\n    response.on('data', function (chunk) {\n      stream.receive(chunk);\n    });\n    response.on('error', function (error) {\n      stream.emit('error', error);\n    });\n    response.on('end', function () {\n      stream.emit('end', response);\n    });\n  });\n  request.on('error', function (error) {\n    stream.emit('error', error);\n  });\n  request.end();\n\n  if (typeof callback === 'function') {\n    callback(stream);\n  } else {\n    return stream;\n  }\n};\n\nmodule.exports = Twitter;","map":null,"metadata":{},"sourceType":"script"}